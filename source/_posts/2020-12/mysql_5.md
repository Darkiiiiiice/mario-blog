---
title: MySQL(五)
date: '2020-12-20 13:40:00'
category: MySQL
author: MarioMang
cover: /resources/images/default_cover.gif
updated: '2020-12-20 13:40:00'
---

# MySQL(五)

### 创建高性能的索引
索引是存储引擎用于快速找到记录的一种数据结构

#### 索引
在MySQL中, 存储引擎用类似的方法使用索引, 其先在索引中找到对应值, 然后根据匹配的索引记录找到对应的数据行  
索引可以包含一个或多个列的值, 如果索引包含多个列, 那么列的顺序也十分重要, 因为MySQL只能高效的使用索引的最左前缀列

> ORM工具能够产生符合逻辑的, 合法的查询, 除非只是生成非常基本的查询, 否则很难生成适合索引的查询

##### 索引类型
不同的场景使用不同类型的索引会获得更好的性能, MySQL中的索引是在存储引擎层实现的, 所以并没有统一的索引标准

###### B-Tree类型
InnoDB使用的是B+Tree, B-Tree通常意味着所有的值都是按照顺序存储的, 并且每一个叶子节点到根节点的距离相同  
B-Tree索引能够加快访问数据的速度, 因为存储引擎不再需要进行全表扫描来获取需要的数据, 取而代之的是从索引的根节点开始进行搜索  
B-Tree索引列是顺序组织存储的, 所以很适合查找范围数据

索引对多个值进行排序的依据是CREATE TABLE语句中定义索引时列的顺序

可以使用B-Tree索引的查询类型
* 全值匹配  
	全值匹配指的是和索引中的所有列进行匹配
* 匹配最左前缀  
	只使用索引的第一列
* 匹配列前缀  
	匹配某一列值的开头部分
* 匹配范围值  
	匹配一定范围内的值
* 精确匹配某一列并范围匹配另外一列
* 只访问索引的查询

下面是一些关于B-Tree索引的限制
* 如果不是按照索引的最左列开始查找, 则无法使用索引
* 不能跳过索引中的列
* 如果查询中有某个列的范围查询, 则其右边所有列都无法使用索引优化查找

###### Hash索引
哈希索引基于哈希表实现, 只有精确匹配索引所有列的查询才有效  
对于每一行数据, 存储引擎都会对所有的索引列计算一个HashCode, 并且不同键值的行计算出来的HashCode也不一样  
在MySQL中, 只有Memory引擎显式支持哈希索引

哈希索引限制:
* 哈希索引只包含哈希值和行指针, 而不是存储字段值, 所以不能使用索引中的值, 来避免读取行
* 哈希索引数据并不是按照索引值顺序存储的, 所以无法用于排序
* 哈希索引也不支持部分索引列匹配查找, 因为哈希索引始终是使用索引列的全部内容进行哈希计算的
* 哈希索引只支持等值比较查询
* 访问哈希索引的数据非常快, 除非有很多哈希冲突
* 如果哈希冲突很多的化, 一些索引维护操作的代价会很高

如果存储引擎不支持哈希索引, 则就可以在B-Tree基础上创建一个伪哈希索引, 在查找时使用的是HashCode进行查找, 而不是键本身

当使用哈希索引进行查询时, 出现了哈希冲突的时候, 查询就无法正常工作, 所以可以在查询条件中带入哈希值和对应的列值

###### 空间数据索引(R-Tree)
MyISAM表支持空间索引, 可以用作地理数据存储, 这类索引无需前缀查询, 空间索引会从所有维度来索引数据

###### 全文索引
全文索引是一种特殊类型的索引, 它查找的是文本中的关键词, 而不是直接比较索引中的值, 全文索引更类似于搜索引擎的事情

### 索引的优点
索引可以快速的定位到数据在表中的位置

1. 索引大大减少了服务器需要扫描的数据量
2. 索引可以帮助服务器避免排序和临时表
3. 索引可以将随机I/O变为顺序I/O

### 索引策略

#### 独立的列
如果查询中的列不是独立的, 则MySQL就不会使用索引  
> 我们应该养成简化WHERE的习惯, 始终将索引列单独放在比较符号的一侧

常见错误:
1. select user_id from user where user_id + 1 = 5;
2. select user_id from user where TO_DAYS(CURRENT_DATE) - TO_DAYS(birth_day) <= 20;

#### 前缀索引
为了解决索引很长字符列, 导致索引变得大而且慢的问题, 通常可以索引开始的部分字符, 这样可以节省索引空间, 提高索引效率, 但是会降低索引的选择性

前缀索引是一种能使索引更小, 更快的有效办法, 但MySQL无法使用前缀索引做Group By和ORDER BY, 也无法使用前缀索引做覆盖扫描

#### 多列索引
未每个列创建独立的索引, 或者按照错误的顺序创建多列索引, 都是错误的概念

在多个列上建立独立的单列索引, 大部分情况下并不能提高MySQL的查询性能, MySQL5.0引入了一种索引合并的策略, 一定程度上可以使用标上的多个单列索引来定位指定行

* 当需要对多个索引做相交操作的时候, 通常意味需要建立一个包含所有相关列的多列索引, 而不是多个独立的单列索引

#### 选择合适的索引顺序
正确的顺序依赖于使用该索引的查询, 并且同时需要考虑如何更好的满足排序和分组的需要  
再一个多列B-Tree索引中, 索引列的顺序意味着索引首先按照最左列进行排序, 其次是第二列等等, 所以索引可以按照升序或者降序进行扫描

#### 聚簇索引
聚簇索引并不是一种单独的索引类型, 而是一种存储方式  
当表中有聚簇索引时, 它的数据行存放在索引的叶子节点中, 因为无法把数据行存放在两个不同的地方, 所以一张表只能有一个聚簇索引

如果没有定义主键, InnoDB会选择一个唯一的非空索引代替, 如果没有非空索引, InnoDB会隐式定义一个主键来作为聚簇索引

聚簇索引优点
* 可以把相关数据保存在一起
* 数据访问更快
* 使用覆盖索引扫描的查询可以直接使用也节点中的主键值

聚簇索引缺点
* 局促数据最大限度的提高了I/O密集型应用的性能, 但如果数据全部在内存中, 聚簇索引就没有优势
* 插入速度严重依赖于插入顺序
* 更新聚簇索引列的代价很高, 因为InnoDB会将每个被更新的行移动到新的位置
* 基于聚簇索引的表在插入新行, 或者主键被更新导致需要移动行的时候, 可能会面临页分裂的问题
* 聚簇索引可能导致全表扫描变慢, 尤其时行比较系数, 或者由于页分裂导致数据库存储不连续的时候
* 二级索引可能比想象的更大, 因为二级索引的叶子节点包含了引用行的主键列
* 二级索引访问需要两次索引查找, 而不是一次

在InnoDB表中按照主键顺序插入行
最好避免随机的聚簇索引, 特别时对于I/O密集型的应用, 随机的聚簇索引没有任何聚集特性

如果使用UUID作为主键, 不仅花费时间更长, 而且索引占用的空间更大  
因为主键时顺序插入的, 所以InnoDB把每一条记录都存储在上一条记录的后面, 当达到页的最大填充因子时, 下一条记录就会写入新的页中  
如果使用UUID作为主键, 每行主键的值, 不一定比上一条的值大, 所以InnoDB无法简单的把新行插入到索引的最后, 而是要为新行寻找合适的位置

缺点:
* 写入的目标页可能已经刷到此盘上并从缓存中移除, 或者没有被加载到缓存中, InnoDB在插入之前不得不线找到并从磁盘读取目标页到内存中, 这将导致大量的随机I/O
* 因为写入是乱序的, InnoDB不得不频繁的做分页操作, 以便为新的行分配空间, 页分裂会导致移动大量数据, 一次插入最少需要修改三个页而不是一个页
* 由于频繁的页分裂, 页会变得系数并被不规则的填充, 最终产生数据碎片

#### 覆盖索引
通常会根据 WHERE 条件来创建合适的索引, 不过这是索引优化的一个方式
更好的方式应该考虑到整个查询, 而不单单时WHERE部分  
MySQL可以使用索引来直接获取列的数据, 这样就不需要再读取数据行  

覆盖索引的好处:
* 索引条目通常远小于数据行大小, 所以如果只需要读取索引, 那MySQL就会极大的减少数据访问量
* 因为索引时按照列值顺序存储的, 所以I/O密集型的范围查询会比随机从磁盘读取每一行数据的I/O要少的很多
* 一些存储引擎如MyISAM在内存中只缓存索引, 数据则依赖于操作系统来换此, 因此访问数据需要一次系统调用
* 由于InnoDB的聚簇索引, 覆盖索引对InnoDB表也别有用, InnoDB二级索引在叶子节点保存了行的主键值, 所以如果二级索引能够覆盖查询, 则可以避免对主键索引进行二次查询

#### 索引扫描排序
MySQL有两种方式可以生成有序的结果: 
* 通过排序操作
* 按索引顺序扫描

只有当索引的列的顺序和ORDER BY子句的顺序完全一致, 并且所有列的排序方向都一样时, MySQL才能够使用索引来对结果进行排序  
如果关联很多张表时, 只有当ORDER BY子句引用的字段全部为第一张表时, 才能使用索引做排序

#### 冗余和重复索引
重复索引是指在相同的列上按照相同的顺序创建的相同的索引

MySQL的唯一限制和主键限制都是通过索引实现的, 所以没有必要再为主键设置一个UNIQUE索引

冗余索引通常发生在为表添加新的索引时, 应该尽量扩展已有的索引, 而不是创建新的索引


#### 索引和锁
索引可以让查询锁定更少的行

InnoDB 会在访问行的时候对行进行加锁, 而索引能够减少InnoDB访问的行数, 从而减少锁的数量  
如果索引无法过滤掉无效的行, 那么在InnoDB检查到数据并返回给服务器层以后, MySQL服务器才能应用WHERE子句

### 注意

* 支持多种过滤条件
	> 在有更多不同值的列上创建索引的选择性会更好
* 避免多个范围条件
* 优化排序