---
title: MySQL(六)
date: '2020-12-20 17:40:00'
category: MySQL
author: MarioMang
cover: /resources/images/default_cover.gif
updated: '2020-12-20 17:40:00'
---

# MySQL(六)

## 查询性能优化

### 优化数据访问

* 是否向数据库请求了不需要的数据  
	以下都数据典型的案例
	* 查询不需要的记录  
		常见的误会, MySQL 会只返回不需要的数据, 实际上MySQL会先返回全部结果集, 再进行计算
	* 多表关联时返回全部列
	* 总是取出全部列
	* 重复查询相同的数据
* MySQL是否在扫描额外的记录  
	通过以下指标分析
	* 响应时间  
		响应时间是服务时间和排队时间之和
	* 扫描的行数和返回的行数  
		理想情况下扫描的行数和返回的函数应该时相同的
	* 扫描的行数的访问类型  

	一般MySQL能够使用如下三种方式应用WHERE条件
	* 在索引中使用WHERE条件来过滤不匹配的记录
	* 使用索引覆盖扫描来返回记录, 直接从索引中过滤不需要的记录并返回命中的结果
	* 从数据表中返回数据, 然后过滤不满足条件的记录


### 重构查询方式

* 拆分复杂查询  
	设计查询时, 可以将一个复杂的查询拆分成为多个简单的查询  
	以前会考虑到打开连接和断开连接对网络资源的消耗, 所以会尽量将查询一次性完成以节省网络资源的消耗, 但这在现代网络中已经不是大问题了

* 切分查询
	通过分而治之的思想, 将大查询切分为小查询, 每次查询功能完全一样, 多次返回小部分数据

* 分解关联查询
	将关联查询分解, 每一个表进行一次单表查询, 然后将结果在应用程序中进行关联

	分解关联查询的优势:
	* 缓存效率更高, 许多应用程序可以方便的缓存单表查询对应的结果
	* 将查询分解后, 执行单个查询可以减少锁竞争
	* 在应用层做关联, 可以更容易做到高性能和可扩展
	* 查询效率也可能会有所提高
	* 可以减少冗余记录的查询
	* 这样相当于在应用层做了哈希关联

### 执行查询
MySQL执行查询的步骤
1. 客户端发送了一条查询给服务器
2. 服务器先检查查询缓存, 如果命中了缓存, 则直接返回存储在缓存中的结果
3. 服务器解析SQL, 预处理, 再由优化器生成对应的执行计划
4. MySQL根据优化器生成的执行计划, 调用存储引擎的API来执行查询
5. 将结果返回给客户端

查询状态
> 对于每个MySQL连接, 任何时刻都有一个状态, 该状态表示了MySQL当前正在做什么
1. Sleep 线程正在等待客户端发送新的请求
2. Query 线程正在执行查询或者正在将结果发送给客户端
3. Locked 在MySQL服务层, 该线程正在等待表锁
4. Analyzing and statistics 线程正在收集存储引擎统计信息, 并生成查询的执行计划
5. Coping to tmp table 线程正在执行查询, 并且将其结果集都复制到一个临时表中, 这个状态一般都在做GROUP BY, 文件排序, UNION操作
6. Sorting result 线程正在对结果集排序
7. Sending data

查询缓存  
> 在解析一个查询语句之前, 如果查询缓存是打开的, 那么MySQL会优先检查这个查询是否命中查询缓存中的数据, 根据查询语句的哈希进行查询

查询优化处理
> 将SQL转换成一个执行计划, MySQL在依照这个执行计划和存储引擎进行交互
* 词法解析器和预处理  
	MySQL通过关键字将SQL语句进行解析, 并生成一颗解析树, MySQL解析器将使用MySQL语法规则验证和解析查询
* 查询优化器  
	MySQL使用基于成本的优化器, 它将尝试与测一个查询使用某种执行计划时的版本, 并选择其中成本最小的一个

下面是MySQL能够处理的优化类型
* 重新定义关联表的顺序  
	数据表的关联并不总是按照在查询中指定的顺序进行
* 将外连接转化成内连接  
	并不是所有的OUTER JOIN语句都必须以外连接的方式执行
* 使用等价变换规则  
	MySQL可以使用一些等价变换来简化并规范表达式
* 优化COUNT(), MIN(), MAX()  
	索引和列是否可为空通常可以帮助MySQL优化这类表达式
* 预估并转化为常熟表达式  
	当MySQL检测到一个表达式可以转化为常数的时候, 就会一直把该表达式作为常数进行优化处理
* 覆盖索引扫描  
	当索引中的列包括所有查询中需要使用的列的时候, MySQL就可以使用索引返回需要的数据, 而无须查询对应的数据行
* 子查询优化  
	MySQL在某些情况下可以将子查询转换一种效率更高的时候, 从而减少多少个查询多次数据进行访问
* 提前终止查询  
	在发现已经满足产寻需求的时候, MySQL总是能够立刻终止查询
* 等值传播  
	如果两个列的值通过等式关联, 那么MySQL能够把其中一个列的WHERE传递到另一个列上
* 列表IN()的比较  
	很多系统中, IN操作完全等同于多个OR条件的子句

MySQL如何执行关联查询  
> MySQL认为每一次查询都是一次关联, 并不仅仅是一个查询需要到两个表匹配才叫做关联  
> MySQL对任何关联都执行嵌套循环关联操作, 即:  
> MySQL会在一个表中循环取出单条数据, 然后再嵌套循环到下一个表中寻找匹配的行, 直到找到所有表中匹配的行

排序优化  
* 两次传输排序  
	读取行指针和需要排序的字段, 对齐进行排序, 然后再根据排序结果读取所需要的数据行
* 单次传输排序  
	先读取查询所需要的所有列, 然后再根据给定列进行排序, 最后直接返回排序结果



